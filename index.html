<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pro Deriv Barrier & MACD Dashboard - Advanced</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      background-color: #0a0a0a;
      color: #00ffe0;
      font-family: 'Orbitron', sans-serif;
      margin: 0;
      padding: 0;
    }
    header {
      background: linear-gradient(to right, #ff0040, #ff9900);
      padding: 20px;
      text-align: center;
      font-size: 2em;
      color: #fff;
      text-shadow: 0 0 10px #ff0040;
      letter-spacing: 0.04em;
    }
    #chart-container {
      width: 100vw;
      max-width: 100vw;
      height: 540px;
      margin: 10px auto 0 auto;
      background: #111;
      border: 2px solid #00ffe0;
      border-radius: 10px;
      overflow-x: auto;
    }
    canvas { width: 100vw !important; height: 100% !important;}
    .controls {
      display: flex; flex-wrap: wrap; justify-content: center;
      gap: 14px; margin: 12px;
    }
    select, input[type=number] {
      background-color: #111; color: #00ffe0;
      border: 2px solid #00ffe0; padding: 8px;
      font-size: 1em; border-radius: 8px;
    }
    label { color: #00ffe0;}
    #signalLog {
      width: 99vw; max-width: 99vw;
      margin: 12px auto; padding: 8px;
      background: #111;
      border: 2px solid #00ffe0;
      border-radius: 10px;
      color: #00ffe0;
      font-family: 'Orbitron', sans-serif;
    }
    #signalLog h3 { margin: 0 0 6px; text-align: center;}
    #signalList {
      list-style: none;
      padding-left: 10px;
      max-height:240px;
      overflow-y:auto;
    }
    #signalList li {
      margin-bottom: 5px;
      border-bottom: 1px solid #00ffe0;
      font-size:1.12em;
    }
    .entry { color: #0f0; font-weight: bold;}
    .exit { color: #ff0040; font-weight: bold;}
    .predict { color: #ff0; font-weight: bold;}
    .safe { color: #0ff; }
    .risky { color: #ff9900; font-weight: bold;}
    .macd-up { color: #00ff00; font-weight: bold;}
    .macd-down { color: #ff8000; font-weight: bold;}
    .trend { color: #ffffff; background: #222; border-radius: 4px; padding: 1px 8px;}
    .volatility { color: #00ffe0; }
    .multi { color: #ffa500;}
    @media (max-width: 800px) {
      #chart-container, #signalLog { width: 99vw; max-width: 99vw; }
      .controls { flex-direction: column; align-items:center; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header>Pro Deriv Barrier & MACD Dashboard (Advanced)</header>
  <div class="controls">
    <select id="volatilitySelector">
      <option value="R_10">Volatility 10 Index</option>
      <option value="R_25">Volatility 25 Index</option>
      <option value="R_50">Volatility 50 Index</option>
      <option value="R_75" selected>Volatility 75 Index</option>
      <option value="R_100">Volatility 100 Index</option>
      <option value="R_10_1HZ">Volatility 10 (1s)</option>
      <option value="R_25_1HZ">Volatility 25 (1s)</option>
      <option value="R_50_1HZ">Volatility 50 (1s)</option>
      <option value="R_75_1HZ">Volatility 75 (1s)</option>
      <option value="R_100_1HZ">Volatility 100 (1s)</option>
    </select>
    <select id="growthRateSelector">
      <option value="1">Growth Rate: 1%</option>
      <option value="2">Growth Rate: 2%</option>
      <option value="3">Growth Rate: 3%</option>
      <option value="4">Growth Rate: 4%</option>
      <option value="5">Growth Rate: 5%</option>
    </select>
    <label>RSI: <input type="number" id="rsiPeriod" value="14" min="4" max="30" size="3"></label>
    <label>EMA: <input type="number" id="emaPeriod" value="50" min="10" max="100" size="3"></label>
    <button onclick="applySettings()">‚öôÔ∏è Apply</button>
  </div>

  <div id="chart-container">
    <canvas id="priceChart"></canvas>
  </div>

  <div id="signalLog">
    <h3>üìã Signal Log (live, every tick, with prediction & multi-indicator confirmation)</h3>
    <ul id="signalList"></ul>
  </div>

  <!-- Audio Alerts -->
  <audio id="entrySound" src="https://cdn.pixabay.com/audio/2022/08/20/audio_12c1b2b3e7.mp3"></audio>
  <audio id="exitSound" src="https://cdn.pixabay.com/audio/2022/10/16/audio_128bfae3c9.mp3"></audio>
  <audio id="predictSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_115b4d9b9e.mp3"></audio>
  <audio id="safeSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_115b4d9b9e.mp3"></audio>
  <audio id="macdUpSound" src="https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-beep-221.mp3"></audio>
  <audio id="macdDownSound" src="https://assets.mixkit.co/sfx/preview/mixkit-warning-notification-93.mp3"></audio>
  <audio id="riskySound" src="https://cdn.pixabay.com/audio/2022/11/16/audio_125bfa8e76.mp3"></audio>
  <audio id="multiSound" src="https://cdn.pixabay.com/audio/2022/11/16/audio_125bfa8e76.mp3"></audio>

  <script>
    // --- Configuration
    const app_id = 1089, api_token = "lKcYGLpmaAMgUkH";
    let ws = null, tickPrices = [], tickTimes = [];
    const maxTicks = 400;
    let barrier = null, growthRate = 1, selectedSymbol = "R_75";
    let lastCross = null, lastPrediction = null, justCrossed = false;
    let lastMacdCross = null, macdArr = [], signalArr = [];
    let lastSafe = false, lastRisky = false, lastMulti = false;
    let lastTrend = null, lastVol = null, lastLog = "";
    let rsiPeriod = 14, emaPeriod = 50;

    // Chart: price + barrier + EMA + MACD + Signal + RSI
    const ctx = document.getElementById('priceChart').getContext('2d');
    let priceChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Price', data: [], borderColor: '#00ffe0', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0, yAxisID: 'y' },
          { label: 'Barrier', data: [], borderColor: '#ff0040', borderWidth: 2, borderDash: [8, 6], tension: 0, pointRadius: 0, pointHoverRadius: 0, yAxisID: 'y' },
          { label: 'EMA', data: [], borderColor: '#ffa500', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0, yAxisID: 'y' },
          { label: 'MACD', data: [], borderColor: '#0f0', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0, yAxisID: 'macd' },
          { label: 'Signal', data: [], borderColor: '#ff0', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0, yAxisID: 'macd' },
          { label: 'RSI', data: [], borderColor: '#00ffe0', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0, yAxisID: 'rsi' },
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#fff' } } },
        scales: {
          y: { position:'left', title:{display:true, text:'Price/Barrier/EMA', color:'#00ffe0'},
            ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.08)' } },
          macd: { position:'right', title:{display:true, text:'MACD', color:'#0f0'},
            ticks: { color: '#0f0' }, grid: { display:false }, min:-5, max:5 },
          rsi: { position: 'right', title:{display:true, text:'RSI', color:'#00ffe0'},
            display: false, min: 0, max: 100
          }
        }
      }
    });

    let lastLogMsg = "";
    function logSignal(message, type = "") {
      if (message === lastLogMsg) return; // Avoid duplicate logs
      lastLogMsg = message;
      const logItem = document.createElement('li');
      logItem.textContent = message;
      if (type) logItem.className = type;
      const list = document.getElementById('signalList');
      if (list.childNodes.length > 250) list.removeChild(list.lastChild);
      list.prepend(logItem);
    }

    function playSound(id) {
      var audio = document.getElementById(id);
      if(audio) { audio.pause(); audio.currentTime = 0; audio.play(); }
    }

    function applySettings() {
      selectedSymbol = document.getElementById('volatilitySelector').value;
      growthRate = parseFloat(document.getElementById('growthRateSelector').value);
      rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
      emaPeriod = parseInt(document.getElementById('emaPeriod').value);
      tickPrices = []; tickTimes = [];
      barrier = null; lastCross = null; lastPrediction = null; justCrossed = false;
      lastMacdCross = null; macdArr = []; signalArr = [];
      lastSafe = false; lastRisky = false; lastMulti = false;
      lastTrend = null; lastVol = null; lastLog = "";
      priceChart.data.labels = [];
      priceChart.data.datasets.forEach(ds=>ds.data=[]);
      priceChart.update();
      connectToDeriv();
    }

    function connectToDeriv() {
      if (ws) { ws.onclose=null; ws.onerror=null; ws.close(); ws=null; }
      ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
      ws.onopen = () => { ws.send(JSON.stringify({ authorize: api_token })); };
      ws.onmessage = msg => {
        try {
          const data = JSON.parse(msg.data);
          if (data.msg_type === "authorize") ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 }));
          if (data.msg_type === "tick") {
            const price = parseFloat(data.tick.quote), time = data.tick.epoch * 1000;
            if (!isFinite(price)) return;
            tickPrices.push(price); tickTimes.push(time);
            if (tickPrices.length > maxTicks) { tickPrices.shift(); tickTimes.shift(); }
            if (barrier === null) barrier = price * (1 + growthRate / 100);
            updatePriceChart();
          }
        } catch (err) { console.error("Error handling message:", err); }
      };
    }

    function calculateEMA(period, prices) {
      if (prices.length < 1) return [];
      const k = 2 / (period + 1); let ema = prices[0], result = [ema];
      for (let i = 1; i < prices.length; i++) {
        ema = prices[i] * k + ema * (1 - k); result.push(ema);
      }
      return result;
    }

    function calculateRSI(period, prices) {
      if (prices.length < period+1) return [];
      let rsi = [];
      for (let i=period; i<prices.length; i++) {
        let gain = 0, loss = 0;
        for (let j=i-period+1; j<=i; j++) {
          let diff = prices[j]-prices[j-1];
          if (diff > 0) gain += diff;
          else loss -= diff;
        }
        let rs = gain / (loss || 1);
        rsi.push(100 - (100 / (1 + rs)));
      }
      return Array(prices.length - rsi.length).fill(null).concat(rsi);
    }

    function calculateATR(period, prices) {
      if (prices.length < period+1) return null;
      let atr = 0;
      for (let i=prices.length-period; i<prices.length; i++) {
        atr += Math.abs(prices[i]-prices[i-1]);
      }
      atr = atr/period;
      return atr;
    }

    function getTrend(prices, ema) {
      if (!ema || ema.length<2) return null;
      let price = prices[prices.length-1], emaVal = ema[ema.length-1];
      if (price > emaVal) return "up";
      if (price < emaVal) return "down";
      return "flat";
    }

    function getVolatility(prices, period=20) {
      if (prices.length < period+1) return null;
      let atr = calculateATR(period, prices);
      let mean = 0;
      for (let i=prices.length-period; i<prices.length; i++) mean += prices[i];
      mean /= period;
      return atr/mean;
    }

    function multiIndicatorConfirm(macd, signal, rsiArr, trend, curr, barrier) {
      let res = [];
      // Only enter if MACD cross up, RSI > 50 and price above EMA and trend up
      if (macd && signal && rsiArr && trend) {
        let macdCross = macd[macd.length-2]<signal[signal.length-2] && macd[macd.length-1]>signal[signal.length-1];
        let rsi = rsiArr[rsiArr.length-1];
        if (
          macdCross &&
          rsi!==null && rsi > 50 &&
          trend==="up" &&
          curr > barrier
        ) {
          res.push("üüß Multi-indicator CONFIRM: STRONG ENTRY (MACD‚Üë, RSI>50, Trend:Up, Price>Barrier)");
        }
        let macdCrossDn = macd[macd.length-2]>signal[signal.length-2] && macd[macd.length-1]<signal[signal.length-1];
        if (
          macdCrossDn &&
          rsi!==null && rsi < 50 &&
          trend==="down" &&
          curr < barrier
        ) {
          res.push("üü® Multi-indicator CONFIRM: STRONG EXIT (MACD‚Üì, RSI<50, Trend:Down, Price<Barrier)");
        }
      }
      return res;
    }

    function updatePriceChart() {
      rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
      emaPeriod = parseInt(document.getElementById('emaPeriod').value);

      priceChart.data.labels = tickTimes.map(()=>"");
      priceChart.data.datasets[0].data = tickPrices;
      priceChart.data.datasets[1].data = Array(tickPrices.length).fill(barrier);

      // EMA calculation
      let emaArr = calculateEMA(emaPeriod, tickPrices);
      priceChart.data.datasets[2].data = emaArr;

      // MACD calculation (12,26,9)
      let macd = [], signal = [];
      if (tickPrices.length >= 26) {
        const emaFast = calculateEMA(12, tickPrices);
        const emaSlow = calculateEMA(26, tickPrices);
        for (let i = 0; i < Math.min(emaFast.length, emaSlow.length); i++)
          macd.push(emaFast[i] - emaSlow[i]);
        signal = calculateEMA(9, macd);

        macdArr = macd; signalArr = signal;

        // Pad MACD/Signal data to align with price data for the chart
        const pad = tickPrices.length - macd.length;
        const macdPlot = Array(pad).fill(null).concat(macd);
        const signalPlot = Array(pad + (macd.length - signal.length)).fill(null).concat(signal);

        priceChart.data.datasets[3].data = macdPlot;
        priceChart.data.datasets[4].data = signalPlot;
      } else {
        priceChart.data.datasets[3].data = [];
        priceChart.data.datasets[4].data = [];
      }

      // RSI
      let rsiArr = calculateRSI(rsiPeriod, tickPrices);
      priceChart.data.datasets[5].data = rsiArr;

      priceChart.update();

      if (tickPrices.length < 2) return;

      const prev = tickPrices[tickPrices.length-2], curr = tickPrices[tickPrices.length-1];
      let summary = [];
      justCrossed = false;

      // ENTRY/EXIT on true cross
      if (prev < barrier && curr >= barrier && lastCross !== 'above') {
        summary.push(`‚úÖ ENTRY: Price crossed upward at ${curr.toFixed(5)}`); playSound("entrySound");
        lastCross = 'above'; lastPrediction = null; justCrossed = true;
      }
      else if (prev > barrier && curr <= barrier && lastCross !== 'below') {
        summary.push(`‚ùå EXIT: Price crossed downward at ${curr.toFixed(5)}`); playSound("exitSound");
        lastCross = 'below'; lastPrediction = null; justCrossed = true;
      }

      // Predict 4 ticks ahead
      if (tickPrices.length >= 5) {
        let v = (tickPrices[tickPrices.length-1] - tickPrices[tickPrices.length-5]) / 4.0;
        let pred = tickPrices[tickPrices.length-1] + v*4;
        if (curr < barrier && pred >= barrier && lastPrediction !== 'entry') {
          summary.push("‚è∞ ENTRY in ~4 sec (predicted)"); playSound("predictSound");
          lastPrediction = 'entry';
        }
        if (curr > barrier && pred <= barrier && lastPrediction !== 'exit') {
          summary.push("‚è∞ EXIT in ~4 sec (predicted)"); playSound("predictSound");
          lastPrediction = 'exit';
        }
      }

      // MACD cross logic
      let macdTxt = "";
      if (macdArr.length >= 2 && signalArr.length >= 2) {
        const prevMACD = macdArr[macdArr.length-2], currMACD = macdArr[macdArr.length-1];
        const prevSignal = signalArr[signalArr.length-2], currSignal = signalArr[signalArr.length-1];
        const prevDiff = prevMACD - prevSignal, currDiff = currMACD - currSignal;
        if (prevDiff < 0 && currDiff > 0 && lastMacdCross !== "up") {
          macdTxt = "üîº MACD crossed ABOVE Signal (bullish momentum)";
          playSound("macdUpSound"); lastMacdCross = "up";
        }
        else if (prevDiff > 0 && currDiff < 0 && lastMacdCross !== "down") {
          macdTxt = "üîΩ MACD crossed BELOW Signal (bearish momentum)";
          playSound("macdDownSound"); lastMacdCross = "down";
        } else if (currDiff > 0) {
          macdTxt = "MACD above Signal";
        } else if (currDiff < 0) {
          macdTxt = "MACD below Signal";
        }
      }
      if (macdTxt) summary.push(macdTxt);

      // RSI/EMA trend filter
      let trend = getTrend(tickPrices, emaArr);
      if (trend && trend !== lastTrend) {
        summary.push(`Trend: ${trend.toUpperCase()}`); lastTrend = trend;
      }

      // Volatility filter
      let volatility = getVolatility(tickPrices, 20);
      if (volatility !== null) {
        let volState = "";
        if (volatility > 0.03) volState = "HIGH";
        else if (volatility < 0.008) volState = "LOW";
        else volState = "MEDIUM";
        if (volState !== lastVol) {
          summary.push(`Volatility: ${volState}`); lastVol = volState;
        }
      }

      // Multi-indicator confirmation
      let multi = multiIndicatorConfirm(macdArr, signalArr, rsiArr, trend, curr, barrier);
      if (multi.length && !lastMulti) {
        summary.push(...multi); playSound("multiSound"); lastMulti = true;
      } else if (!multi.length) lastMulti = false;

      // Risky/Safe
      const distance = Math.abs(barrier - curr);
      if (distance < curr * 0.004) {
        if (!lastRisky) { summary.push("‚ö†Ô∏è RISKY: Price near barrier!"); playSound("riskySound"); }
        lastRisky = true; lastSafe = false;
      } else {
        if (!lastSafe) { summary.push("üü¶ SAFE"); playSound("safeSound"); }
        lastSafe = true; lastRisky = false;
      }

      // Always log, on every tick, but avoid duplicate logs for the same tick
      let logMsg = summary.join(" | ");
      if (!logMsg) logMsg = "üü¶ SAFE";
      logSignal(logMsg,
        logMsg.includes("ENTRY") ? "entry" :
        logMsg.includes("EXIT") ? "exit" :
        logMsg.includes("RISKY") ? "risky" :
        logMsg.includes("SAFE") ? "safe" :
        logMsg.includes("MACD") ? (logMsg.includes("ABOVE") ? "macd-up" : "macd-down") :
        logMsg.includes("Multi-indicator") ? "multi" :
        logMsg.includes("Trend") ? "trend" :
        logMsg.includes("Volatility") ? "volatility" :
        logMsg.includes("predict") ? "predict" : "");
      lastLog = logMsg;
    }

    // Enable audio after user interacts
    window.addEventListener('click', () => {
      document.querySelectorAll('audio').forEach(a => { a.muted = false; });
    }, { once: true });

    window.onload = () => applySettings();
  </script>
</body>
  </html>
