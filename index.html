<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Volatility Barrier Prediction Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { background-color: #0a0a0a; color: #00ffe0; font-family: 'Orbitron', sans-serif; margin: 0; padding: 0;}
    header { background: linear-gradient(to right, #ff0040, #ff9900); padding: 20px; text-align: center; font-size: 2em; color: #fff; text-shadow: 0 0 10px #ff0040;}
    #chart-container { width: 98vw; max-width: 1200px; height: 340px; margin: 20px auto 0 auto; background: #111; border: 2px solid #00ffe0; padding: 8px; border-radius: 10px;}
    canvas { width: 100% !important; height: 100% !important;}
    .controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 14px; margin: 12px;}
    select { background-color: #111; color: #00ffe0; border: 2px solid #00ffe0; padding: 8px; font-size: 1em; border-radius: 8px;}
    #signalLog { width: 98vw; max-width: 1200px; margin: 10px auto; padding: 8px; background: #111; border: 2px solid #00ffe0; border-radius: 10px; color: #00ffe0; font-family: 'Orbitron', sans-serif;}
    #signalLog h3 { margin: 0 0 6px; text-align: center;}
    #signalList { list-style: none; padding-left: 10px; max-height:120px; overflow-y:auto;}
    #signalList li { margin-bottom: 5px; border-bottom: 1px solid #00ffe0; font-size:1.05em; }
    .alert { font-weight: bold; color: #ff0; background: #222; padding: 2px 10px; border-radius: 4px;}
    .safe { color: #0f0; }
    .risk { color: #ff9900; }
    .predicted { color: #00aaff; }
    @media (max-width: 800px) {
      #chart-container, #signalLog { width: 99vw; max-width: 99vw; }
      .controls { flex-direction: column; align-items:center; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header>Volatility Barrier Prediction Dashboard</header>
  <div class="controls">
    <select id="volatilitySelector">
      <option value="R_10">Volatility 10 Index</option>
      <option value="R_25">Volatility 25 Index</option>
      <option value="R_50">Volatility 50 Index</option>
      <option value="R_75" selected>Volatility 75 Index</option>
      <option value="R_100">Volatility 100 Index</option>
      <option value="R_10_1HZ">Volatility 10 (1s)</option>
      <option value="R_25_1HZ">Volatility 25 (1s)</option>
      <option value="R_50_1HZ">Volatility 50 (1s)</option>
      <option value="R_75_1HZ">Volatility 75 (1s)</option>
      <option value="R_100_1HZ">Volatility 100 (1s)</option>
    </select>
    <select id="growthRateSelector">
      <option value="1">Growth Rate: 1%</option>
      <option value="2">Growth Rate: 2%</option>
      <option value="3">Growth Rate: 3%</option>
      <option value="4">Growth Rate: 4%</option>
      <option value="5">Growth Rate: 5%</option>
    </select>
    <button onclick="applySettings()">‚öôÔ∏è Apply</button>
  </div>

  <div id="chart-container">
    <canvas id="priceChart"></canvas>
  </div>

  <div id="signalLog">
    <h3>üìã Signal Log</h3>
    <ul id="signalList"></ul>
  </div>

  <audio id="entrySound" src="https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-beep-221.mp3"></audio>
  <audio id="lossSound" src="https://assets.mixkit.co/sfx/preview/mixkit-tech-breakdown-2478.mp3"></audio>
  <audio id="safeSound" src="https://assets.mixkit.co/sfx/preview/mixkit-positive-notification-951.mp3"></audio>
  <audio id="riskSound" src="https://assets.mixkit.co/sfx/preview/mixkit-warning-notification-93.mp3"></audio>
  <audio id="earlySound" src="https://assets.mixkit.co/sfx/preview/mixkit-tick-tock-clock-timer-1045.mp3"></audio>

  <script>
    const app_id = 1089;
    const api_token = "lKcYGLpmaAMgUkH";
    let ws = null;
    let tickPrices = [];
    let tickTimes = [];
    const maxTicks = 200;
    let barrier = null;
    let growthRate = 1;
    let selectedSymbol = "R_75";
    let lastState = null; // 'SAFE', 'RISK', 'LOSS', 'ENTRY'
    let lastEarlyAlertIdx = -1000;
    let lastPredictedCrossIdx = -1000;

    // Chart.js setup: three lines (price, barrier, prediction)
    const ctx = document.getElementById('priceChart').getContext('2d');
    let priceChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Price', data: [], borderColor: '#00ffe0', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0 },
          { label: 'Barrier', data: [], borderColor: '#ff0040', borderWidth: 2, borderDash: [8, 6], tension: 0, pointRadius: 0, pointHoverRadius: 0 },
          { label: 'Prediction', data: [], borderColor: '#00aaff', borderWidth: 2, borderDash: [2,7], tension: 0, pointRadius: 0, pointHoverRadius: 0 }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#fff' } } },
        scales: {
          x: { display: false },
          y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.08)' } }
        }
      }
    });

    function logSignal(message, type="") {
      const logItem = document.createElement('li');
      logItem.textContent = message;
      if (type) logItem.className = type;
      const list = document.getElementById('signalList');
      if (list.childNodes.length > 80) list.removeChild(list.lastChild);
      list.prepend(logItem);
    }

    function applySettings() {
      selectedSymbol = document.getElementById('volatilitySelector').value;
      growthRate = parseFloat(document.getElementById('growthRateSelector').value);
      tickPrices = [];
      tickTimes = [];
      barrier = null;
      lastState = null;
      lastEarlyAlertIdx = -1000;
      lastPredictedCrossIdx = -1000;
      priceChart.data.labels = [];
      priceChart.data.datasets.forEach(ds=>ds.data=[]);
      priceChart.update();
      connectToDeriv();
    }

    function connectToDeriv() {
      if (ws) { ws.onclose=null; ws.onerror=null; ws.close(); ws=null; }
      ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
      ws.onopen = () => { ws.send(JSON.stringify({ authorize: api_token })); };
      ws.onmessage = msg => {
        try {
          const data = JSON.parse(msg.data);
          if (data.msg_type === "authorize") ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 }));
          if (data.msg_type === "tick") {
            const price = parseFloat(data.tick.quote);
            const time = data.tick.epoch * 1000;
            if (!isFinite(price)) return;
            tickPrices.push(price);
            tickTimes.push(time);
            if (tickPrices.length > maxTicks) { tickPrices.shift(); tickTimes.shift(); }
            if (barrier === null) barrier = price * (1 + growthRate / 100);
            updatePriceChart();
          }
        } catch (err) { console.error("Error handling message:", err); }
      };
    }

    function updatePriceChart() {
      priceChart.data.labels = tickTimes.map(t=>new Date(t));
      priceChart.data.datasets[0].data = tickPrices;
      priceChart.data.datasets[1].data = Array(tickPrices.length).fill(barrier);

      // --- Prediction line (project 4 ticks into the future)
      let predictionArr = [];
      if (tickPrices.length >= 5) {
        let idx0 = tickPrices.length-5;
        let idx1 = tickPrices.length-1;
        let v = (tickPrices[idx1] - tickPrices[idx0]) / 4.0; // ticks are 1s apart
        let predicted = [];
        for (let i=0; i<4; ++i) {
          predicted.push(tickPrices[idx1] + v*(i+1));
        }
        predictionArr = tickPrices.slice();
        for (let i=1; i<=4; ++i)
          predictionArr.push(tickPrices[idx1] + v*i);
        let labels = priceChart.data.labels.slice();
        let lastLabel = labels[labels.length-1] || new Date();
        for (let i=1; i<=4; ++i) {
          labels.push(new Date(+lastLabel + i*1000));
        }
        priceChart.data.labels = labels;
        priceChart.data.datasets[2].data = predictionArr;
      } else {
        priceChart.data.datasets[2].data = [];
      }
      priceChart.update();

      // Signal logic
      if (tickPrices.length < 2) return;
      const curr = tickPrices[tickPrices.length-1];
      const prev = tickPrices[tickPrices.length-2];

      // Entry (first tick)
      if (lastState === null) {
        logSignal(`‚úÖ ENTRY: Trading started at ${curr.toFixed(5)}`, "alert");
        document.getElementById("entrySound").play();
        lastState = "ENTRY";
      }

      // Loss: price crosses barrier
      if ((prev < barrier && curr >= barrier) || (prev > barrier && curr <= barrier)) {
        if (lastState !== "LOSS") {
          document.getElementById("lossSound").play();
          logSignal(`üü• LOSS! Price crossed the barrier at ${curr.toFixed(5)}`, "alert");
          lastState = "LOSS";
        }
      } else {
        // Safe/Risk time
        const distance = Math.abs(barrier - curr);
        if (distance < curr * 0.005) {
          if (lastState !== "RISK") {
            document.getElementById("riskSound").play();
            logSignal(`‚ö†Ô∏è RISK: Price near barrier at ${curr.toFixed(5)}`, "risk");
            lastState = "RISK";
          }
        } else {
          if (lastState !== "SAFE") {
            document.getElementById("safeSound").play();
            logSignal(`üü© SAFE: Price safely away from barrier (${curr.toFixed(5)})`, "safe");
            lastState = "SAFE";
          }
        }
      }

      // Early warning: predict 4 ticks (4 seconds) ahead
      if (tickPrices.length >= 5) {
        let idx0 = tickPrices.length-5;
        let idx1 = tickPrices.length-1;
        let v = (tickPrices[idx1] - tickPrices[idx0]) / 4.0;
        let predPrice = tickPrices[idx1] + v*4;
        const currIdx = tickPrices.length;
        const willBreach = 
          (v > 0 && curr < barrier && predPrice >= barrier) ||
          (v < 0 && curr > barrier && predPrice <= barrier);
        if (willBreach && currIdx - lastEarlyAlertIdx > 10) {
          document.getElementById("earlySound").play();
          logSignal(`‚è∞ EARLY ALERT: Price may cross barrier in ~4s!`, "alert");
          lastEarlyAlertIdx = currIdx;
        }
        // Visual predicted crossing
        if (willBreach && currIdx - lastPredictedCrossIdx > 10) {
          logSignal(`üîÆ TRACKING: Prediction shows a crossing soon!`, "predicted");
          lastPredictedCrossIdx = currIdx;
        }
      }
    }

    window.onload = () => applySettings();
  </script>
</body>
</html>
