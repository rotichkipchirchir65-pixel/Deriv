<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Barrier Entry/Exit Predictor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { background-color: #0a0a0a; color: #00ffe0; font-family: 'Orbitron', sans-serif; margin: 0; padding: 0;}
    header { background: linear-gradient(to right, #ff0040, #ff9900); padding: 20px; text-align: center; font-size: 2em; color: #fff;}
    #chart-container { width: 100vw; max-width: 100vw; height: 430px; margin: 10px auto 0 auto; background: #111; border: 2px solid #00ffe0; border-radius: 10px;}
    canvas { width: 100vw !important; height: 100% !important;}
    .controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 14px; margin: 12px;}
    select { background-color: #111; color: #00ffe0; border: 2px solid #00ffe0; padding: 8px; font-size: 1em; border-radius: 8px;}
    #signalLog { width: 99vw; max-width: 99vw; margin: 12px auto; padding: 8px; background: #111; border: 2px solid #00ffe0; border-radius: 10px; color: #00ffe0; font-family: 'Orbitron', sans-serif;}
    #signalLog h3 { margin: 0 0 6px; text-align: center;}
    #signalList { list-style: none; padding-left: 10px; max-height:160px; overflow-y:auto;}
    #signalList li { margin-bottom: 5px; border-bottom: 1px solid #00ffe0; font-size:1.05em; }
    .entry { color: #0f0; font-weight: bold;}
    .exit { color: #ff0040; font-weight: bold;}
    .predict { color: #ff0; font-weight: bold;}
    .safe { color: #0ff; }
    @media (max-width: 800px) {
      #chart-container, #signalLog { width: 99vw; max-width: 99vw; }
      .controls { flex-direction: column; align-items:center; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header>Barrier Entry/Exit Predictor</header>
  <div class="controls">
    <select id="volatilitySelector">
      <option value="R_10">Volatility 10 Index</option>
      <option value="R_25">Volatility 25 Index</option>
      <option value="R_50">Volatility 50 Index</option>
      <option value="R_75" selected>Volatility 75 Index</option>
      <option value="R_100">Volatility 100 Index</option>
      <option value="R_10_1HZ">Volatility 10 (1s)</option>
      <option value="R_25_1HZ">Volatility 25 (1s)</option>
      <option value="R_50_1HZ">Volatility 50 (1s)</option>
      <option value="R_75_1HZ">Volatility 75 (1s)</option>
      <option value="R_100_1HZ">Volatility 100 (1s)</option>
    </select>
    <select id="growthRateSelector">
      <option value="1">Growth Rate: 1%</option>
      <option value="2">Growth Rate: 2%</option>
      <option value="3">Growth Rate: 3%</option>
      <option value="4">Growth Rate: 4%</option>
      <option value="5">Growth Rate: 5%</option>
    </select>
    <button onclick="applySettings()">‚öôÔ∏è Apply</button>
  </div>

  <div id="chart-container">
    <canvas id="priceChart"></canvas>
  </div>

  <div id="signalLog">
    <h3>üìã Signal Log</h3>
    <ul id="signalList"></ul>
  </div>
  <audio id="entrySound" src="https://cdn.pixabay.com/audio/2022/08/20/audio_12c1b2b3e7.mp3"></audio>
  <audio id="exitSound" src="https://cdn.pixabay.com/audio/2022/10/16/audio_128bfae3c9.mp3"></audio>
  <audio id="predictSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_115b4d9b9e.mp3"></audio>
  <audio id="safeSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_115b4d9b9e.mp3"></audio>

  <script>
    const app_id = 1089;
    const api_token = "lKcYGLpmaAMgUkH";
    let ws = null;
    let tickPrices = [];
    let tickTimes = [];
    const maxTicks = 200;
    let barrier = null;
    let growthRate = 1;
    let selectedSymbol = "R_75";
    let lastCross = null; // 'above' or 'below'
    let lastPrediction = null;
    let justCrossed = false; // blocks "SAFE" log on cross tick

    // Chart.js setup: price + barrier
    const ctx = document.getElementById('priceChart').getContext('2d');
    let priceChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Price', data: [], borderColor: '#00ffe0', borderWidth: 2, tension: 0.25, pointRadius: 0, pointHoverRadius: 0 },
          { label: 'Barrier', data: [], borderColor: '#ff0040', borderWidth: 2, borderDash: [8, 6], tension: 0, pointRadius: 0, pointHoverRadius: 0 }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { color: '#fff' } } },
        scales: {
          x: { display: false },
          y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.08)' } }
        }
      }
    });

    function logSignal(message, type="") {
      const logItem = document.createElement('li');
      logItem.textContent = message;
      if (type) logItem.className = type;
      const list = document.getElementById('signalList');
      if (list.childNodes.length > 160) list.removeChild(list.lastChild);
      list.prepend(logItem);
    }

    function playSound(id) {
      // For browser sound policies. Will only work after user interacts once.
      var audio = document.getElementById(id);
      if(audio) { audio.pause(); audio.currentTime = 0; audio.play(); }
    }

    function applySettings() {
      selectedSymbol = document.getElementById('volatilitySelector').value;
      growthRate = parseFloat(document.getElementById('growthRateSelector').value);
      tickPrices = [];
      tickTimes = [];
      barrier = null;
      lastCross = null;
      lastPrediction = null;
      justCrossed = false;
      priceChart.data.labels = [];
      priceChart.data.datasets.forEach(ds=>ds.data=[]);
      priceChart.update();
      connectToDeriv();
    }

    function connectToDeriv() {
      if (ws) { ws.onclose=null; ws.onerror=null; ws.close(); ws=null; }
      ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${app_id}`);
      ws.onopen = () => { ws.send(JSON.stringify({ authorize: api_token })); };
      ws.onmessage = msg => {
        try {
          const data = JSON.parse(msg.data);
          if (data.msg_type === "authorize") ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 }));
          if (data.msg_type === "tick") {
            const price = parseFloat(data.tick.quote);
            const time = data.tick.epoch * 1000;
            if (!isFinite(price)) return;
            tickPrices.push(price);
            tickTimes.push(time);
            if (tickPrices.length > maxTicks) { tickPrices.shift(); tickTimes.shift(); }
            if (barrier === null) barrier = price * (1 + growthRate / 100);
            updatePriceChart();
          }
        } catch (err) { console.error("Error handling message:", err); }
      };
    }

    function updatePriceChart() {
      priceChart.data.labels = tickTimes.map(()=>""); // no timezone
      priceChart.data.datasets[0].data = tickPrices;
      priceChart.data.datasets[1].data = Array(tickPrices.length).fill(barrier);
      priceChart.update();

      if (tickPrices.length < 2) return;
      const prev = tickPrices[tickPrices.length-2];
      const curr = tickPrices[tickPrices.length-1];

      justCrossed = false;

      // Detect barrier crossing and log ENTRY/EXIT only on true cross
      if (prev < barrier && curr >= barrier && lastCross !== 'above') {
        logSignal(`‚úÖ ENTRY: Price crossed upward at ${curr.toFixed(5)}`, "entry");
        playSound("entrySound");
        lastCross = 'above';
        lastPrediction = null;
        justCrossed = true;
      }
      else if (prev > barrier && curr <= barrier && lastCross !== 'below') {
        logSignal(`‚ùå EXIT: Price crossed downward at ${curr.toFixed(5)}`, "exit");
        playSound("exitSound");
        lastCross = 'below';
        lastPrediction = null;
        justCrossed = true;
      }

      // Predict 4 ticks ahead
      if (tickPrices.length >= 5) {
        let v = (tickPrices[tickPrices.length-1] - tickPrices[tickPrices.length-5]) / 4.0;
        let pred = tickPrices[tickPrices.length-1] + v*4;
        // If currently below barrier and prediction crosses above: predict ENTRY
        if (curr < barrier && pred >= barrier && lastPrediction !== 'entry') {
          logSignal("‚è∞ ENTRY in ~4 sec (predicted)", "predict");
          playSound("predictSound");
          lastPrediction = 'entry';
        }
        // If currently above barrier and prediction crosses below: predict EXIT
        if (curr > barrier && pred <= barrier && lastPrediction !== 'exit') {
          logSignal("‚è∞ EXIT in ~4 sec (predicted)", "predict");
          playSound("predictSound");
          lastPrediction = 'exit';
        }
      }

      // Log SAFE if not a cross tick or prediction, and not already "SAFE"
      if (!justCrossed && !recentPrediction() && lastCross) {
        // Only log SAFE if not already last SAFE
        if (!lastSafeLogged()) {
          logSignal("üü¶ SAFE", "safe");
          playSound("safeSound");
        }
      }
    }

    function recentPrediction() {
      // Check if the last log is a predict for the same direction
      const list = document.getElementById('signalList');
      if (list.childNodes.length === 0) return false;
      const recent = list.childNodes[0].textContent;
      return (recent && recent.startsWith("‚è∞"));
    }

    function lastSafeLogged() {
      const list = document.getElementById('signalList');
      if (list.childNodes.length === 0) return false;
      const recent = list.childNodes[0].textContent;
      return (recent && recent.includes("SAFE"));
    }

    // User must interact once for audio to play on some browsers
    window.addEventListener('click', () => {
      document.querySelectorAll('audio').forEach(a => { a.muted = false; });
    }, { once: true });

    window.onload = () => applySettings();
  </script>
</body>
        </html>
